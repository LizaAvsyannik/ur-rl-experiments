import rospy
import numpy as np
import torch
import gym
from .gazebo_connection import GazeboConnection
from .controllers_connection import ControllersConnection

class RobotGazeboEnv(gym.Env):

    def __init__(self, ns, controllers_list):
        self.controllers_list = [ns + '/' + ctrl for ctrl in controllers_list]
        self.gazebo = GazeboConnection(ns)
        self.controllers_object = ControllersConnection(ns, controllers_list=controllers_list)
        self.seed(1000 * int(ns) + 7)
        self.episode_num = 0

    # Env methods
    def seed(self, seed=None):
        np.random.seed(seed)
        torch.random.manual_seed(seed)

    def step(self, action):
        """
        Function executed each time step.
        Here we get the action execute it in a time step and retrieve the
        observations generated by that action.
        :param action: CPU tensor of shape (action_space_dim,)
        :return: obs - CPU tensor of shape (obs_space_dim,),
                 reward - float,
                 done - bool,
                 info - dict of strings
        """
        rospy.logdebug("Entered step")
        rospy.logdebug("Unpause sim")
        self.gazebo.unpauseSim()
        rospy.logdebug("Set action")
        rospy.logdebug(f"Action: {action}")
        self._set_action(action)
        rospy.logdebug("Is done")
        done = self._is_done()
        rospy.logdebug("Get Obs")
        obs = self._get_obs()
        self.gazebo.pauseSim()
        reward, done, info = self._compute_reward(obs, done)
        self._reset_env_state()
        return obs, reward, done, info

    def reset(self):
        """ Resets environment and returns a 
            single new observation of shape (obs_space_dim,)
        """
        rospy.logdebug("Reseting RobotGazeboEnvironment")
        self._reset_env_state()
        self._reset_sim()
        self._update_episode()
        obs = self._get_obs()
        self._init_env_variables()
        reward, done, info = self._compute_reward(obs, False)
        return obs, reward, done, info

    def close(self):
        """
        Function executed when closing the environment.
        Use it for closing GUIS and other systems that need closing.
        :return:
        """
        rospy.logdebug("Closing RobotGazeboEnvironment")
        rospy.signal_shutdown("Closing RobotGazeboEnvironment")

    def _update_episode(self):
        """
        Increases the episode number by one
        :return:
        """
        self.episode_num += 1

    # Extension methods
    # ----------------------------
    def _reset_env_state(self):
        """Resets accumulated environment state
        """
        raise NotImplementedError()

    def _reset_sim(self):
        """Resets a simulation
        """
        raise NotImplementedError()

    def _set_init_pose(self):
        """Sets the Robot in its init pose
        """
        raise NotImplementedError()

    def _check_all_systems_ready(self):
        """
        Checks that all the sensors, publishers and other simulation systems are
        operational.
        """
        raise NotImplementedError()

    def _get_obs(self):
        """Returns the observation.
        """
        raise NotImplementedError()

    def _init_env_variables(self):
        """Inits variables needed to be initialised each time we reset at the start
        of an episode.
        """
        raise NotImplementedError()

    def _set_action(self, action):
        """Applies the given action to the simulation.
        """
        raise NotImplementedError()

    def _is_done(self):
        """Indicates whether or not the episode is done ( the robot has fallen for example).
        """
        raise NotImplementedError()

    def _compute_reward(self, observations, done):
        """Calculates the reward to give based on the observations given.
        """
        raise NotImplementedError()

    def _env_setup(self, initial_qpos):
        """Initial configuration of the environment. Can be used to configure initial state
        and extract information from the simulation.
        """
        raise NotImplementedError()
        